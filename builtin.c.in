#include "alloc.h"
#include "builtin.h"
#include "env.h"
#include "punky.h"

/* @BUILTIN_SINGLETONS@ */

/* @BUILTIN_DECLS@ */

#define ZERO_ARGS(e) ((e) == &NIL)

#define ATLEAST_ONE_ARG(e) ((e)->s_type == S_LIST)

#define EXACTLY_ONE_ARG(e) ATLEAST_ONE_ARG ((e)) && ZERO_ARGS ((e)->cdr)

#define EXACTLY_TWO_ARG(e)                                                    \
  ((e)->s_type == S_LIST && EXACTLY_ONE_ARG ((e)->cdr))

#define EXPECT(e, TYPE, errmsg)                                               \
  if (e->s_type != (TYPE))                                                    \
  return new_err (0, errmsg)

#define EVAL_EXPECT(env, arg, e, TYPE, errmsg)                                \
  sexpr *e = sexpr_eval (env, arg);                                           \
  if (e->s_type != TYPE)                                                      \
    {                                                                         \
      return new_err (e, errmsg);                                             \
    }

#define WALK_LIST(env, args, e, TYPE, ACTION, errmsg)                         \
  const sexpr *list = args;                                                   \
  for (; list->s_type == S_LIST; list = list->cdr)                            \
    {                                                                         \
      EVAL_EXPECT (env, list->car, e, TYPE, errmsg);                          \
      ACTION;                                                                 \
      sexpr_free (e);                                                         \
    }                                                                         \
  if (list != &NIL)                                                           \
  return new_err (0, "malformed arguments")

static sexpr *
builtin_apply_ADD (environment *env, const sexpr *args)
{
  int r = 0;
  WALK_LIST (env, args, e, S_INT, r += e->ival, "numeric type required");
  return new_int (r);
}

static sexpr *
builtin_apply_MUL (environment *env, const sexpr *args)
{
  int r = 1;
  WALK_LIST (env, args, e, S_INT, r *= e->ival, "numeric type required");
  return new_int (r);
}

static sexpr *
builtin_apply_SUB (environment *env, const sexpr *args)
{
  if (!ATLEAST_ONE_ARG (args))
    return new_err (0, "subtraction requires at least one argument");
  EVAL_EXPECT (env, args->car, e, S_INT, "numeric type required");

  if (ZERO_ARGS (args->cdr))
    { // special case
      e->ival = -e->ival;
      return e;
    }

  int r = e->ival;
  sexpr_free (e);

  // guaranteed to be either S_INT or S_ERR
  sexpr *rest = builtin_apply_ADD (env, args->cdr);
  if (rest->s_type == S_ERR)
    return rest;

  rest->ival = r - rest->ival;
  return rest;
}

static sexpr *
builtin_apply_DIV (environment *env, const sexpr *args)
{
  if (!ATLEAST_ONE_ARG (args))
    return new_err (0, "division requires at least one argument");
  EVAL_EXPECT (env, args->car, e, S_INT, "numeric type required");

  if (ZERO_ARGS (args->cdr))
    { // special case
      if (e->ival == 0)
        return new_err (e, "divide by zero");

      e->ival = 1 / e->ival;
      return e;
    }

  int r = e->ival;
  sexpr_free (e);

  // guaranteed to be either S_INT or S_ERR
  sexpr *rest = builtin_apply_MUL (env, args->cdr);
  if (rest->s_type == S_ERR)
    return rest;

  if (rest->ival == 0)
    return new_err (rest, "divide by zero");

  rest->ival = r / rest->ival;
  return rest;
}

static sexpr *
builtin_apply_CAR (environment *env, const sexpr *args)
{
  if (!EXACTLY_ONE_ARG (args))
    return new_err (0, "car requires exactly one argument");

  EVAL_EXPECT (env, args->car, list, S_LIST, "car requires a list argument")

  sexpr *car = sexpr_copy (list->car); // TODO inefficient...
  sexpr_free (list);
  return car;
}

static sexpr *
builtin_apply_CDR (environment *env, const sexpr *args)
{
  if (!EXACTLY_ONE_ARG (args))
    return new_err (0, "car requires exactly one argument");

  EVAL_EXPECT (env, args->car, list, S_LIST, "cdr requires a list argument")

  sexpr *cdr = sexpr_copy (list->cdr); // TODO inefficient...
  sexpr_free (list);
  return cdr;
}

static sexpr *
builtin_apply_CONS (environment *env, const sexpr *args)
{
  if (!EXACTLY_TWO_ARG (args))
    return new_err (0, "cons requires exactly two arguments");

  sexpr *car = sexpr_eval (env, args->car);
  if (car->s_type == S_ERR)
    return car;

  sexpr *cdr = sexpr_eval (env, args->cdr->car);
  if (cdr->s_type == S_ERR)
    {
      sexpr_free (car);
      return cdr;
    }

  return new_list (car, cdr);
}

static sexpr *
builtin_apply_OR (environment *env, const sexpr *args)
{
  sexpr *b = (sexpr *)&FALSE;
  WALK_LIST (env, args, e, S_BOOL,
             b = (sexpr *)((b == &TRUE || e == &TRUE) ? &TRUE : &FALSE),
             "boolean type required");
  return b;
}

static sexpr *
builtin_apply_AND (environment *env, const sexpr *args)
{
  sexpr *b = (sexpr *)&TRUE;
  WALK_LIST (env, args, e, S_BOOL,
             b = (sexpr *)((b == &TRUE && e == &TRUE) ? &TRUE : &FALSE),
             "boolean type required");
  return b;
}

static sexpr *
builtin_apply_DEFINE (environment *env, const sexpr *args)
{
  if (!ATLEAST_ONE_ARG (args))
    return new_err (0, "malformed arguments to define");

  const sexpr *key;
  EXPECT ((key = args->car), S_IDENT, "non-identifier provided to define");

  if (ZERO_ARGS (args->cdr))
    { // special case
      return env_del (env, key->sval);
    }
  else if (!EXACTLY_ONE_ARG (args->cdr))
    return new_err (0, "unexpected extra arguments to define");

  sexpr *value = sexpr_eval (env, args->cdr->car);

  if (value->s_type == S_ERR)
    return value;

  env_set (env, key->sval, value);

  return new_ident (key->sval);
}

static sexpr *
builtin_apply_LAMBDA (environment *env, const sexpr *args)
{
  if (!EXACTLY_TWO_ARG (args))
    return new_err (0, "lambda requires exactly two arguments");

  EXPECT (args->car, S_LIST, "malformed arguments to lambda");

  sexpr *params = args->car, *e;
  for (e = params; e->s_type == S_LIST; e = e->cdr)
    {
      EXPECT (e->car, S_IDENT, "non-identifier in lambda param list");
    }

  sexpr *body = args->cdr->car;

  return new_fun (sexpr_copy (params), sexpr_copy (body));
}

sexpr *
sexpr_apply_builtin (environment *env, const sexpr *builtin, const sexpr *args)
{
  switch (builtin->b_type)
    {
      /* @BUILTIN_CASES@ */

    default:
      return new_err (0, "unknown/unimplemented builtin %d\n",
                      builtin->b_type);
    }
}
