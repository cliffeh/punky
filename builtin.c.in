#include "alloc.h"
#include "builtin.h"
#include "env.h"
#include "punky.h"

/* @BUILTIN_SINGLETONS@ */

/* @BUILTIN_DECLS@ */

#define EXPECT(e, TYPE, errmsg)                                               \
  if (e->s_type != (TYPE))                                                    \
  return new_err (0, errmsg)

#define EVAL_EXPECT(env, arg, e, TYPE, errmsg)                                \
  sexpr *e = sexpr_eval (env, arg);                                           \
  if (e->s_type != TYPE)                                                      \
    {                                                                         \
      return new_err (e, errmsg);                                             \
    }

#define WALK_LIST(env, args, e, TYPE, ACTION, errmsg)                         \
  const sexpr *list = args;                                                   \
  for (; list->s_type == S_LIST; list = list->cdr)                            \
    {                                                                         \
      EVAL_EXPECT (env, list->car, e, TYPE, errmsg);                          \
      ACTION;                                                                 \
      sexpr_free (e);                                                         \
    }                                                                         \
  if (list != &NIL)                                                           \
  return new_err (0, "malformed arguments")

static sexpr *
builtin_apply_ADD (environment *env, const sexpr *args)
{
  int r = 0;
  WALK_LIST (env, args, e, S_INT, r += e->ival, "numeric type required");
  return new_int (r);
}

static sexpr *
builtin_apply_MUL (environment *env, const sexpr *args)
{
  int r = 1;
  WALK_LIST (env, args, e, S_INT, r *= e->ival, "numeric type required");
  return new_int (r);
}

static sexpr *
builtin_apply_SUB (environment *env, const sexpr *args)
{
  EXPECT (args, S_LIST, "subtraction requires at least one argument");
  EVAL_EXPECT (env, args->car, e, S_INT, "numeric type required");

  if (args->cdr == &NIL)
    { // special case
      e->ival = -e->ival;
      return e;
    }

  int r = e->ival;
  sexpr_free (e);

  // guaranteed to be either S_INT or S_ERR
  sexpr *rest = builtin_apply_ADD (env, args->cdr);
  if (rest->s_type == S_ERR)
    return rest;

  rest->ival = r - rest->ival;
  return rest;
}

static sexpr *
builtin_apply_DIV (environment *env, const sexpr *args)
{
  EXPECT (args, S_LIST, "division requires at least one argument");
  EVAL_EXPECT (env, args->car, e, S_INT, "numeric type required");

  if (args->cdr == &NIL)
    { // special case
      if (e->ival == 0)
        return new_err (e, "divide by zero");

      e->ival = 1 / e->ival;
      return e;
    }

  int r = e->ival;
  sexpr_free (e);

  // guaranteed to be either S_INT or S_ERR
  sexpr *rest = builtin_apply_MUL (env, args->cdr);
  if (rest->s_type == S_ERR)
    return rest;

  if (rest->ival == 0)
    return new_err (rest, "divide by zero");

  rest->ival = r / rest->ival;
  return rest;
}

static sexpr *
builtin_apply_CAR (environment *env, const sexpr *args)
{
  if (args->s_type != S_LIST || args->cdr != &NIL)
    return new_err (0, "car requires exactly one argument");

  sexpr *list = sexpr_eval (env, args->car);
  if (list->s_type != S_LIST)
    return new_err (list, "car requires a list argument");

  sexpr *car = sexpr_copy (list->car); // TODO inefficient...
  sexpr_free (list);
  return car;
}

static sexpr *
builtin_apply_CDR (environment *env, const sexpr *args)
{
  if (args->s_type != S_LIST || args->cdr != &NIL)
    return new_err (0, "cdr requires exactly one argument");

  sexpr *list = sexpr_eval (env, args->car);
  if (list->s_type != S_LIST)
    return new_err (list, "cdr requires a list argument");

  sexpr *cdr = sexpr_copy (list->cdr); // TODO inefficient...
  sexpr_free (list);
  return cdr;
}

static sexpr *
builtin_apply_DEFINE (environment *env, const sexpr *args)
{
  EXPECT (args, S_LIST, "malformed arguments to define");

  const sexpr *key;
  EXPECT ((key = args->car), S_IDENT, "non-identifier provided to define");

  if (args->cdr == &NIL)
    { // special case
      return env_del (env, key->sval);
    }
  EXPECT (args->cdr, S_LIST, "malformed arguments to define");
  if (args->cdr->cdr != &NIL)
    return new_err (0, "unexpected extra arguments to define");

  sexpr *value = sexpr_eval (env, args->cdr->car);

  if (value->s_type == S_ERR)
    return value;

  env_set (env, key->sval, value);

  return new_ident (key->sval);
}

static sexpr *
builtin_apply_LAMBDA (environment *env, const sexpr *args)
{
  EXPECT (args, S_LIST, "malformed arguments to lambda");
  EXPECT (args->car, S_LIST, "malformed arguments to lambda");

  sexpr *params = args->car, *e;
  for (e = params; e->s_type == S_LIST; e = e->cdr)
    {
      EXPECT (e->car, S_IDENT, "non-identifier in lambda param list");
    }

  EXPECT (args->cdr, S_LIST, "malformed arguments to lambda");
  if (args->cdr->cdr != &NIL)
    return new_err (0, "unexpected extra arguments to lambda");
  sexpr *body = args->cdr->car;

  return new_fun (sexpr_copy (params), sexpr_copy (body));
}

sexpr *
sexpr_apply_builtin (environment *env, const sexpr *builtin, const sexpr *args)
{
  switch (builtin->b_type)
    {
      /* @BUILTIN_CASES@ */

    default:
      return new_err (0, "unknown/unimplemented builtin %d\n", builtin->b_type);
    }
}
