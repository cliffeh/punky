#include "alloc.h"
#include "builtin.h"
#include "env.h"
#include "punky.h"

/* @BUILTIN_SINGLETONS@ */

/* @BUILTIN_DECLS@ */

#define EXPECT(e, TYPE, errmsg)                                               \
  if (e->s_type != (TYPE))                                                    \
  return new_err (errmsg)

#define EVAL_EXPECT(env, arg, e, TYPE, errmsg)                                \
  sexpr *e = sexpr_eval (env, arg);                                           \
  if (e->s_type != TYPE)                                                      \
    {                                                                         \
      sexpr *err = new_err (errmsg);                                          \
      err->cdr = e;                                                           \
      return err;                                                             \
    }

#define WALK_LIST(env, args, e, TYPE, ACTION, errmsg)                         \
  const sexpr *list = args;                                                   \
  for (; list->s_type == S_LIST; list = list->cdr)                            \
    {                                                                         \
      EVAL_EXPECT (env, list->car, e, TYPE, errmsg);                          \
      ACTION;                                                                 \
      sexpr_free (e);                                                         \
    }                                                                         \
  if (list != &NIL)                                                           \
  return new_err ("malformed arguments")

static sexpr *
builtin_apply_ADD (environment *env, const sexpr *args)
{
  int r = 0;
  WALK_LIST (env, args, e, S_INT, r += e->ival, "numeric type required");
  return new_int (r);
}

static sexpr *
builtin_apply_MUL (environment *env, const sexpr *args)
{
  int r = 1;
  WALK_LIST (env, args, e, S_INT, r *= e->ival, "numeric type required");
  return new_int (r);
}

static sexpr *
builtin_apply_SUB (environment *env, const sexpr *args)
{
  EXPECT (args, S_LIST, "subtraction requires at least one argument");
  EVAL_EXPECT (env, args->car, e, S_INT, "numeric type required");

  if (args->cdr == &NIL)
    { // special case
      e->ival = -e->ival;
      return e;
    }

  int r = e->ival;
  sexpr_free (e);

  // guaranteed to be either S_INT or S_ERR
  sexpr *rest = builtin_apply_ADD (env, args->cdr);
  if (rest->s_type == S_ERR)
    return rest;

  rest->ival = r - rest->ival;
  return rest;
}

static sexpr *
builtin_apply_DIV (environment *env, const sexpr *args)
{
  EXPECT (args, S_LIST, "division requires at least one argument");
  EVAL_EXPECT (env, args->car, e, S_INT, "numeric type required");

  if (args->cdr == &NIL)
    { // special case
      if (e->ival == 0)
        {
          sexpr *err = new_err ("divide by zero");
          err->cdr = e;
          return err;
        }
      e->ival = 1 / e->ival;
      return e;
    }

  int r = e->ival;
  sexpr_free (e);

  // guaranteed to be either S_INT or S_ERR
  sexpr *rest = builtin_apply_MUL (env, args->cdr);
  if (rest->s_type == S_ERR)
    return rest;
  if (rest->ival == 0)
    {
      sexpr *err = new_err ("divide by zero");
      err->cdr = e;
      return err;
    }

  rest->ival = r / rest->ival;
  return rest;
}

static sexpr *
builtin_apply_CONS (environment *env, const sexpr *args)
{
  return new_err("i don't know from CONS");
}

static sexpr *
builtin_apply_DEFINE (environment *env, const sexpr *args)
{
  EXPECT (args, S_LIST, "malformed arguments to define");

  const sexpr *key;
  EXPECT ((key = args->car), S_IDENT, "non-identifier provided to define");

  if (args->cdr == &NIL)
    { // special case
      return env_del (env, key->sval);
    }
  EXPECT (args->cdr, S_LIST, "malformed arguments to define");
  if (args->cdr->cdr != &NIL)
    return new_err ("unexpected extra arguments to define");

  sexpr *value = sexpr_eval (env, args->cdr->car);

  if (value->s_type == S_ERR)
    return value;

  env_set (env, key->sval, value);

  return new_ident (key->sval);
}

static sexpr *
builtin_apply_LAMBDA (environment *env, const sexpr *args)
{
  EXPECT (args, S_LIST, "malformed arguments to lambda");
  EXPECT (args->car, S_LIST, "malformed arguments to lambda");

  sexpr *params = args->car, *e;
  for (e = params; e->s_type == S_LIST; e = e->cdr)
    {
      EXPECT (e->car, S_IDENT, "non-identifier in lambda param list");
    }

  EXPECT (args->cdr, S_LIST, "malformed arguments to lambda");
  if (args->cdr->cdr != &NIL)
    return new_err ("unexpected extra arguments to lambda");
  sexpr *body = args->cdr->car;

  return new_fun (sexpr_copy (params), sexpr_copy (body));
}

sexpr *
sexpr_apply_builtin (environment *env, const sexpr *builtin, const sexpr *args)
{
  switch (builtin->b_type)
    {
      /* @BUILTIN_CASES@ */

    default:
      return new_err ("unknown/unimplemented builtin %d\n", builtin->b_type);
    }
}
